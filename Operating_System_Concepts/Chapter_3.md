# Chapter 3

1. 关于thread && process:
   > - A thread and a process are both units of execution that are used to manage the execution of a program on a computer. 
   > - Process can be thought of as a container that holds all the resources that are required for the program to run. 
   > - A thread, on the other hand, is a lightweight, independent unit of execution within a process. 
   > - A process is an instance of a program, and a thread is a separate flow of execution within a process. A process can contain multiple threads, each of which can execute independently of the others.  
2. 如果将指令的准备以及执行抽象成一个指令池和流水线，那么前面体系结构的学习中有很重要的一部分(指令级并行)是在讲，如何在流水线上采用各种技巧来高效地执行这些指令；而到了OS，比如文中提到"The objective of multiprogramming is to have some process running at all times so as to maximize CPU utilization."，不难看出multiprogramming地目标是把流水线前面的指令池填满，最好让池子始终保持填满的状态，以维持二者提供和消耗指令**速度对等**的效果，在这种情况下可以maximize CPU utilization。  
3. 关于exec() return还是有疑问 GUESSED: exec() system call如果成功执行的话肯定不会return anything，因为没有意义，原来的program已经被replace，return的东西就没人用了；所以应该是没有"return xxx;"这种语句，会有"if(xxx) {ERRNO = xxx; return -1;}"这种 
   > - https://en.wikipedia.org/wiki/Exec_(system_call)#Return_value
   > - A successful exec replaces the current process image, so it cannot return anything to the program that made the call. Processes do have an exit status, but that value is collected by the parent process.
   > - 关于ChatGPT：在现阶段还是少用吧，用在那种答案很直接的问题上应该没问题，但是一些复杂拗口的就可能会给出错误的答案，比如exec()后pid不变，它说会变；现阶段还是一个开放接口给大众来训练模型的阶段，根据用户的reactions来reinforce模型，来改进问题的答案；如果我并没有对"exec()后会有一个new pid"这种答案做出任何reaction，可能下一个人问到相同问题时还会是这个错误答案，但是总有人会指出来的，当ChatGPT能精准回答出大部分问题时，应该就是它开始收费的阶段了:)
4. The wait() system call then retrieves the exit status of the child process from the child's PCB and stores it in the memory location passed as an argument to the wait() system call. In this way, the parent process can access the exit status of the child process and determine if the child process terminated successfully or if an error occurred. // the general idea is that the exit status of the child process is stored in a separate memory location before the PCB is deallocated. exit()和wait()的交互差不多清楚了，但是如果子进程的returned value不是exit status，而是其他值，比如一个算某个数平方的子进程，那它的返回值可能就是某一个数的平方，没有exit status的含义了，这时候还要传给exit()吗？？？可能跟进一步的IPC有关？？？我们都知道returned value是要给exit()的，然后放进子进程的PCB里，父进程得知子进程要结束后来到子进程的PCB retrieve exit status，一旦retrieve完毕，exit()继续执行，销毁子进程(包括其PCB)；怎么又说the process table contains the process’s exit status :confused:  
   > - When a child process calls the exit() function, it passes an exit status as a parameter to the function. This exit status is then stored by the operating system in a specific memory location, typically known as the child's process control block (PCB). The PCB is a data structure that the operating system uses to store information about a process, such as its state, priority, and resources. 
   > - When the parent process calls the wait() system call, it suspends its execution and waits for one of its child processes to terminate. Once a child process terminates and calls the exit() function, the operating system notifies the parent process that one of its child processes has terminated.
   > - The wait() system call then retrieves the exit status of the child process from the child's PCB and stores it in the memory location passed as an argument to the wait() system call. In this way, the parent process can access the exit status of the child process and determine if the child process terminated successfully or if an error occurred.
   > - In summary, when a child process calls the exit() function, it passes an exit status as a parameter, the operating system stores the exit status in a specific memory location, typically known as the child's process control block (PCB), the parent process calls the wait() system call, it suspends its execution and waits for one of its child processes to terminate, once a child process terminates, the wait() system call retrieves the exit status of the child process from the child's PCB and stores it in the memory location passed as an argument to the wait() system call. This way, the parent process can access the exit status of the child process and determine if the child process terminated successfully or if an error occurred.
   > ---
   > - You are correct that the process control block (PCB) of a child process is typically deallocated by the operating system once the child process terminates. However, the exit status of the child process is typically stored in a separate memory location by the operating system before the PCB is deallocated.
   > - When a child process calls the exit() function, it passes an exit status as a parameter. The operating system stores the exit status in a specific memory location and marks the child process as terminated. The parent process can then call the wait() system call, which retrieves the exit status of the child process from the memory location where the operating system stored it and stores it in the memory location passed as an argument to the wait() system call. Once the parent process has retrieved the exit status of the child process, the operating system can safely deallocate the child's PCB.
   > - It's worth mentioning that different operating systems may have different implementation of exit() and wait() system call and the process control block (PCB) management, but the general idea is that the exit status of the child process is stored in a separate memory location before the PCB is deallocated.
   > - In summary, once the child process terminates and calls the exit() function, the operating system stores the exit status in a specific memory location, and marks the child process as terminated. The parent process can then call the wait() system call, which retrieves the exit status of the child process from the memory location where the operating system stored it and stores it in the memory location passed as an argument to the wait() system call, once the parent process has retrieved the exit status of the child process, the operating system can safely deallocate the child's PCB.  
5. under normal termination, exit() will be called indirectly, as the `C run-time library` (which is added to UNIX executable files) will include a call to exit() by default，如果没有return statement，默认返回0，默认成功执行，当然还要看具体实现，有些也会默认返回1或者-1  
   > A common way for the ***main function*** to return is by using the "return xxx;" statement, where xxx is an integer value that represents the exit status of the program. When the ***main function*** returns, the C run-time library's exit() function will be called, and the exit status of the program will be passed as an argument to the exit() function.  
6. 第二个问题：in "the return code for the fork() is zero for the new (child) process, whereas the (nonzero) process identifier of the child is returned to the parent.", how does fork() implement it, creating a new memory space for child process, then returning zero to child process and nonzero(pid of child process) to parent process? ChatGPT的回答：存疑？？？
   > The operating system then sets the return value of fork() to zero in the child process's stack and the PID of the child process in the parent process's stack. When the child process starts executing, it retrieves the value of the fork() return from its stack, which is zero, and assigns it to a variable. Similarly, when the parent process resumes execution after the fork() call, it retrieves the value of the fork() return from its stack, which is the PID of the child process, and assigns it to a variable. This allows the parent process to communicate and synchronize with the child process if necessary.  
   > They(Parent/Child process) can then inspect the call's return value to determine their status, child or parent, and act accordingly.
7. P162 "a web application in any tab crashes, the entire process―including all other tabs displaying additional websites crashes as well." 这是早期的设计，为什么  
8. P163 "Message passing is useful for exchanging smaller amounts of data, because no conflicts need be avoided. Message passing is also easier to implement in a distributed system than shared memory.(Although there are systems that provide distributed shared memory, we do not consider them in this text.)" 为什么  
9. P168 "Nonblocking receive: The receiver retrieves either a valid message or a null." means:  
   > When defining a non-blocking receive operation as "The receiver retrieves either a valid message or a null", it means that the receiver will attempt to retrieve a message, but if there is no message available, it will not block and wait for a message to arrive, instead it will retrieve a "null" or "empty" value. A null value is a special value that represents the absence of a value or an "empty" value. In this context, it means that there is no message available to be received. This allows the receiver to check if a message has been received, and if not, to take appropriate action or continue executing other tasks. For example, the receiver can check if the received message is null, and if so, it can continue with other tasks, otherwise, it can process the received message. This is different from a blocking receive operation, where the receiver will wait until a message is available to be received and will not proceed with other tasks. It's worth noting that this type of non-blocking receive operation is also called "polling" where a process polls a communication channel repeatedly to check if a message is available, and it can be useful in situations where the process can't afford to be blocked and wait for a message to arrive.  
10. shared-memory和message-passing里都有bufferG，可以想一下区别之类的，总感觉message-passing model里有一种跟shared-memory一样，就是那种，既然有了A，干嘛还需要B的感觉  
11. P170 "the mmap() function establishes a memory-mapped file containing the shared-memory object. It also returns a pointer to the memory-mapped file that is used for accessing the shared-memory object." 关于POSIX shared memory的实现：首先用shm_open()造一个shared memory object，这个应该是在disk里；然后用ftruncate()指定大小；最后用mmap()将object映射到calling process的virtual address space里  
12. P173 "The Mach kernel supports the creation and destruction of multiple tasks, which are similar to processes but have multiple threads of control and fewer associated resources.", why "fewer associated resources"  
   > In traditional operating systems, a process typically has a single thread of control and its own set of associated resources. These resources are typically allocated to the process when it is created, and are not shared with other processes. So, compared to Mach tasks, traditional processes in other operating systems don't have threads of control by default, but they can have multiple threads of control. 
13. P173 "Each port may have multiple senders, but only one receiver."(The only receiver is the port's owner who created it no matter whhich sender is) "A port’s owner may also manipulate the capabilities for a port. This is most commonly done in establishing a reply port." "It also identifies the rights for the port. Each port right represents a name for that port, and a port can only be accessed via a right."?  
   > Each port right is a token that represents the name of the port and grants the holder of the right access to the port, allowing them to send or receive messages to and from it.  
14. P173 "Mach uses ports to represent resources such as tasks, threads, memory, and processors, while message passing provides an object-oriented approach for interacting with these system resources and services."  
15. P174 mach_port_allocate()最后一个参数感觉有问题  
16. P174 "Each task also has access to a bootstrap port, which allows a task to register a port it has created with a system-wide bootstrap server."?  
17. P176 "Therefore, the message itself is never actually copied, as both the sender and receiver access the same memory. This message-management technique provides a large performance boost but works only for intrasystem messages." 跟POSIX shared-memory那个例子里用到的技巧一样(Chapter 10 virtual-memory-management techniques)，都是把一块space映射到virtual memory space里，前者要映射的内容在disk里，如果用传统的I/O肯定要大量时间，而后者主要是为了减少message copy的时间；" Message passing may occur between any two ports on the same host or on separate hosts on a distributed system." 同时该技巧也有一个局限是只能intrasystem，因为只有在单独一个系统内部才好管理address space，牵扯到不同system应该会困难起来，所以跨系统/分布式系统内部的message passing估计还要copy，**题外话：可以想办法克服这一点吗，还有就是message pssing和shared-memory两种IPC model感觉有好多相似的地方，见前面的10.，或者说它们用到的都是通用的技巧，那么二者的不同之处/优缺点是什么呢，可以思考一下**  
18. 关于modularity：  
   > - The phrase "the limited modularity of the resulting process definitions" refers to the degree to which the process definitions can be broken down into smaller, independent, and reusable components.
   > - Modularity in software development refers to the ability to divide a large, complex system into smaller, more manageable, and independent parts, that can be developed and tested separately. When it comes to process definitions, modularity implies that the process definitions can be defined in a way that they can be easily reused, extended, and composed with other process definitions to create more complex systems.
   > - When the modularity of process definitions is limited, it means that the process definitions are tightly coupled and dependent on each other, making it difficult to reuse or extend them without affecting other parts of the system. This can make the system harder to maintain, understand, and evolve over time.
   > - Therefore, limited modularity of the resulting process definitions implies that the process definitions are not easily reusable, extensible, and composable and may hinder the maintainability and scalability of the system.  
19. P177 "Additionally, communication channels support a callback mechanism that allows the client and server to accept requests when they would normally be expecting a reply." callback mechanism?  
20. Unix里的pipe是一种特殊的文件，很形象，有两个元素的整型数组，元素是file descriptor，我感觉file descriptor和port/mailbox的相同点是都代表了一些东西，有点上面讲的那种面向对象方法学的感觉，不同点是file descriptor只有代表的含义，但是port/mailbox内部都还有东西，message queue之类的。pipe是unidirectional，我觉得不能看父进程和子进程之间的双向交流，要看pipe，它就是从读端到写端，无所谓谁读谁写，所以还是unidirectional。pipe就是无所谓对象的文件的读写，两个文件代表着两端，为什么不能是一个文件呢？那不就是shared-memory了，再联想一下前面Mach里的"reply port"，也是一个port负责receive，另一个port负责response，有好处  
21. Linux系统直接把管道实现成了一种文件系统，借助VFS给应用程序提供操作接口。虽然实现形态上是文件，但是管道本身并不占用磁盘或者其他外部存储的空间。在Linux的实现上，它占用的是内存空间。所以，Linux上的管道就是一个操作方式为文件的内存缓冲区。  
22. P186 "Socket client = sock.accept();" GUESSED: socket.accept()这个方法返回一个socket，显然这应该是发出request的client一端的socket，注意，client端的socket早就存在了，只不过server端不知道，直到发过来一个请求，server才知道并且构建了一个client端的socket MODIFIED: "Socket sock = new Socket("127.0.0.1",6013);" client端可以通过如上形式构建自己的socket，并向参数里标明的IP和port number发出请求，server端"When a client connects to the server, the accept() method returns a new socket that is bound to the client's IP address and port. This socket can be used by the server to communicate with the client and send/receive data."  
   > A network socket is a software structure within a network node of a computer network that serves as an endpoint for sending and receiving data across the network. Sockets are created only during the lifetime of a process of an application running in the node.
23. 关于port，知乎上有文章写的挺好，我现在遇到了三种port：第一种是学汇编时遇到的port，即硬件端口，就是寄存器，CPU可以直接寻址，CPU与外设沟通的媒介；第二种时学IPC时遇到的mailbox/port，"The queue associated with each port is finite in size and is initially empty. As messages are sent to the port, the messages are copied into the queue."，也有自己的port number，应该就是buffer；第三种是在学RPC时，"A port in this context is simply a number included at the start of a message packet. Whereas a system normally has one network address, it can have many ports within that address to differentiate the many network services it supports. If a remote process needs a service, it addresses a message to the proper port."，牵扯到network上的不同machine时，就牵扯到了各种application protocol，这里的port更多的意思是单纯的数字，表征client&&server端的端口号，当然这个数字之下也有buffer来缓冲一些message  
24. P188 关于RPCs "RPCs can fail, or be duplicated and executed more than once, as a result of common network errors."：  
   > RPCs can be duplicated and executed more than once if the network experiences communication issues, such as network congestion, network partition, or network delay, that result in the failure of the original RPC to reach the server, causing the client to retry the same request. Additionally, if the server crashes after executing the original request but before sending the response, the client might not know whether the request was processed or not, leading it to resend the request, causing the RPC to be executed twice. To mitigate this issue, most RPC systems implement techniques such as idempotency, sequence numbers, and retransmission to detect and avoid duplicated RPCs.
25. 关于timestamp是如何防止repeated messages还是有点疑惑  
26. P171/172 POSIX shared-memory 两段代码(producer process && consumer process)感觉有错误  
   > - [APPRORIATE use for POSIX shared-memory API][1]，应该把`mmap(0, SIZE, PROT READ | PROT WRITE, MAP SHARED, fd, 0);`分别改成`PROT_READ`和`PROT_WRITE`
   > - <https://support.xilinx.com/s/question/0D52E00006hpU0FSAU/cant-compile-shmopen?language=en_US>，首先是无法编译通过程序，报错"undefined reference to `shm_open`"，必须在gcc里加上`-lrt`，因为诸如`shm_open()`/`shm_unlink()`/`sem_timedwait()`/`mq_timedsend()`/`sched_rr_get_interval()`这些"are part of the real-time extension of the POSIX standard, which provides support for real-time programming and enables processes to meet deadlines in response to external events."；在程序变成可执行文件的过程中可能需要run-time library的帮助，因为header-files里只有declaration，真正的implementation在run-time library里，那么当我们使用gcc命令时可能需要显式地加上`-lrt`(如上所示)，而其他情况好像默认就会链接运行时库，为什么？"It depends on what functions you are using from the rt library. If you are using functions from the ***real-time extension of the POSIX standard***, then you may need to link with the rt library by adding `-lrt` when you compile your program. However, if you are not using any functions from the real-time extension, then you do not need to link with the rt library."
   > - <https://stackoverflow.com/questions/9923495/undefined-reference-shm-open-already-add-lrt-flag-here>，关于使用gcc命令生成可执行文件时，对于链接库命令的顺序有要求(不知道新版本还有没有要求)
27. 使用 System V message queue 实现进程间通信  
   > <https://feichashao.com/ipc-mq/>  
28. 关于process states && queue:  
   > <https://www.tutorialspoint.com/what-are-the-different-types-of-process-states-and-queues>  
   > <https://courses.cs.washington.edu/courses/cse410/99au/lectures/Lecture-11-01/tsld009.htm>
29. 关于虚拟内存：With enough privileges, processes can request the kernel to map part of another process's memory space to its own, as is the case for debuggers. 与debugger有什么关系  
   > <https://en.wikipedia.org/wiki/User_space_and_kernel_space> 


[1]: https://www.geeksforgeeks.org/posix-shared-memory-api/