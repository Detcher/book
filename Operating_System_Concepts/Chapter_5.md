# Chapter 5

1. P266 On modern operating systems it is kernel-level threads―not processes―that are in fact being scheduled by the operating system...However, in many instances in this chapter, when we use the general terminology of scheduling a process to "run on a CPU", we are implying that the process is running on a CPU’s core.  
2. P268 "The records in the queues are generally process control blocks (PCBs) of the processes." 有必要在queue里存process的PCB吗？  
3. ***[:CONTROVERSY:]*** P269 "A nonpreemptive kernel will wait for a system call to complete or for a process to block while waiting for I/O to complete to take place before doing a context switch." 感觉后半部分有点错误，按照书上写的，非抢占式内核发生上下文切换只有两种情况：自然退出或者进程由running state转为waiting state，也就是说进程本身有需求(注意与ready state的区别，后者不是进程本身有需求，而是受到了外界不可控的中断，所以ta不需要wait什么，ta随时都是ready的；更贴切点说，前者是voluntary，后者是nonvoluntary)；因此，我觉得非抢占式内核在发生上下文切换前不会等待因为需要I/O而阻塞的进程的完成，而是切换至另一个process  
4. P269 "A preemptive kernel requires mechanisms such as mutex locks to prevent race conditions when accessing shared kernel data structures." 想到了一个metaphor：当两个process都要访问shared-data时可能会发生race conditions，就好比有A(老)/B(幼)两个人一盘菜，按辈分来说，应该让A先吃，B吃的时候是A吃完剩下的，race conditions就是A正准备夹菜，B立马**抢占**了A，把A踢到一边，这时候肯定有风险啊，B吃的不是A剩下的，不是A改变过的；因此对于抢占式内核，需要互斥锁这类机制，A正吃的时候把A围住，不让B抢占ta；非抢占式内核一定会保证让A吃完再让B上桌。  
5. P271 关于voluntary context-switch以及nonvoluntary context-switch:  
   > A voluntary context switch occurs when a process has given up control of the CPU because it requires a resource that is currently unavailable (such as blocking for I/O.) Anonvoluntary context switch occurs when the CPU has been taken away from a process, such as when its time slice has expired or it has been preempted by a higher-priority process.  
6. 关于Shell:  
   > Both the "shell process generated each time by starting a new process" and the "shell" you open by typing "cmd" are types of shell, but they have different purposes and behaviors. The shell you open by typing "cmd" is a user interface that allows you to interact with the operating system by typing commands and executing programs. This type of shell is known as a terminal or command-line interface. On the other hand, the "shell process generated by starting a new process" is a separate process created by the operating system to manage the execution of the new process. It is responsible for starting and controlling the new process, and can perform actions such as setting environment variables, redirecting input/output, and managing process execution. This type of shell process runs in the background and is not directly accessible by the user. In short, the "shell process generated by starting a new process" is an internal component of the operating system that helps manage process execution, while the "shell" you open by typing "cmd" is a user-facing interface for interacting with the operating system.
7. P275 "The next CPU burst is generally predicted as an exponential average of the measured lengths of previous CPU bursts." 关于"exponential average": 
   > - The exponential average, also known as the ***exponentially weighted moving average***, is a method of calculating the average of a set of data points over time, where more recent data points have a higher weight than older data points. In this method, the average of the data is calculated by applying a weight to each data point, where the weight decreases exponentially as the data point becomes older.  
   > - "exponentially weighted moving average"，很形象，感觉就是在说recent和history points的权重不同，会随着时间（往回）以指数级变化  
   > - P275 "The value of tn contains our most recent information, while τn stores the past history."，`τn`是最近一次的预测历史，`tn`是最近一次的历史，因为`τn`作为预测肯定是发生在`tn`之前的，所以原文中说"stores the past history"也不足为奇，结合最近一次的预测及实际来预算出next burst  
8. `FCFS`(nonpreemptive)会发生convoy effect，告诉我们应该让需求时间少的先执行，需要很长时间执行的process往后排；`SJF`则通过exponential average的方法预测队列里每一个process的next CPU burst，短的先执行，当然如果队列里新来的process的burst time比当前执行的process的剩余burst time还短，按是否让其执行完，又有抢占式(`SRTF`，最短剩余时间先)和非抢占式之分，注意当几个process的burst time都相同时，采用FCFS来选择一执行；`RR`是利用time quantum，timer，以及环形队列实现的抢占式的FCFS，小于time quantum直接自愿退出，大于time quantum，会耗尽timer，触发中断，进行上下文切换。另外，关于turnaround time (从进队列到执行完毕) In general, the average turnaround time can be improved if most processes finish their next CPU burst in a single time quantum。显然，关于time quantum的大小就是一个问题，太小就会有过多的context switch (thus, the context-switch time is a small fraction of the time quantum)，太大就会退化成FCFS，因此，A rule of thumb is that 80 percent of the CPU bursts should be shorter than the time quantum；`PS`是一种general的scheduling，equal-priority就是FCFS，带priority就是SJF；有抢占式和非抢占式两种；最大的问题是starvation，解决办法是aging (还有一种是combination of round-robin and priority scheduling，挑最高优先级的run，同等优先级的用RR，但是我感觉没有解决痛点，还是可能会出现indefinite blocking)；`MLQS`是为了提高PS找到highest priority process的速度，一般来说如果只有一个queue，时间复杂度为O(n) (有两种情况：第一种是这一个queue本来就是无序的，那么找到最高优先级的进程肯定是O(n)；第二种是这个queue里的process按优先级排列，那么不就是O(1)了吗？但是为了维护这个"优先队列"同样需要O(n)，来了一个新的，遍历插入需要O(n)，当然用堆结构可以优化至O(logN)，或者直接用MLQ，以空间换时间；这就要tradeoff了:) 可以根据process type (感觉也是priority的体现，但是是externally defined)或者priority划分多个queue，不同queue内可以采取不同的scheduling algorithm，队伍间用fixed-priority preemptive scheduling或者time-slice；`MLFQS` 抢占式的 This setup has the advantage of low scheduling overhead, but it is inflexible. MLQ里的进程都是固定的，进到哪个队列里了以后就一直在那个队列里 (自身的nature不会变)，MLFQ里的进程可以根据规则 (CPU bursts)移动，原文中举的例子在分队列的时候是根据CPU bursts来分的 (没有根据优先级)，最高的优先级给到了CPU bursts最短的，占用CPU时间较长的会被移到低优先级队列里，低优先级队列里等待时间较长的会被移到高优先级队列里，是aging机制的一种形式，a multilevel feedback queue scheduler is defined by some parameters，为这些参数选择合适的值就成了一个问题。关于这一节进程调度的介绍包括了众多算法，我感觉前几个小节讲的是基础的调度算法，FCFS/SJF/RR，他们都可以从PS推出，各自有各自的pros and cons；至此算法上的创新打住，再往下就有了数据结构上的创新，从单队列变成了多队列，那么不同队列自然可以采用不同的基础调度算法，相应的规则也随着数据结构的改变而有了适应性变化  
9. P283 Contention Scope涉及到many-to-many many-to-one one-to-one那几个模型，我在相册里存了三张图 (有LWP在)，结合着应该可以理解PCS/SCS，相当于是有两层contention，一层作为user threads (同一process内)争LWP (根据priority，preemptive且no guarantee of time slicing among threads of equal priority)，一层作为kernel threads争Core，当然对于one-to-one肯定只有SCS，因为LWP是包分配的，不需要争用。在创建线程之前可以改变系统的scope，以Pthreads为例，即使是many-to-many的系统也可以用PTHREAD_SCOPE_SYSTEM scheduling policy改变成one-to-one policy  
10. 有提到multiprocessing/multitasking/multiprogramming
   > <https://en.m.wikipedia.org/wiki/Multiprocessing#:~:text=Multiprocessing%20is%20the%20use%20of,to%20allocate%20tasks%20between%20them.>  
11. 关于SMP/AMP，从processor role的层面看更容易理解些 (symmetric with regard to processor roles)，SMP中每个processor都有着相同的role，而AMP中可能只让一个processor处理code，只让一个处理I/O。当然也可以从memory access time的层面来理解，SMP中每个processor到main memory的时间都是相同的，而AMP中processor到自己临近的与其他处理器的memory时间是不同的。btw，在一致性方面，有两种方法：snoop和directory。对于multiprocessor scheduling (注意现代的multiprocessor的内涵更丰富了，见P286)，如果是AMP，则有一个是master server，负责scheduling decisions/IO这些，其他的processor只是处理user code；如果是SMP，则每个processor都有scheduler，都是self-scheduling的，去queue里找thread执行。那么接下来的问题是，queue在哪里并且以何种方式存在？要么，shared-ready-queue，但是会有race condition，需要locking，但是因为shared的nature以及locking的存在，会成为performance bottleneck；要么，per-core-run-queue，每一个processor都有局部的thread queue，这时候可能出现workloads of varying sizes，造成一些processor的thread queue里可能是满的，其他processor处于idle状态，因此需要load balancing/balancing algorithm的引入。  
12. P287 Each core maintains its architectural state and thus appears to the operating system to be a separate logical CPU. SMP systems that use multicore processors are faster and consume less power than systems in which each CPU has its own physical chip.  
13. 关于hardware thread：
   > <https://stackoverflow.com/questions/5593328/software-threads-vs-hardware-threads#:~:text=Hardware%20threads%20are%20a%20feature,cores%20(%22hyperthreading%22).>
   > Hardware threads are a feature of some processors that allow better utilisation of the processor under some circumstances.  
14.  关于coarse-grained scheduling和fine-grained scheduling还是不太明白，还有hardware threads，它到底是不是kernel level threads
15.  P290 那个two different levels of scheduling好奇怪，拿第一层举例，原文中说是OS来schedule software threads到hardware threads (logical CPU)上，但是前面学的不是由thread library来schedule吗?  
16.  P292 Indeed, they may work against the goals of the scheduling algorithm 说是留作一道练习  
17.  P293 In other words, there is a natural tension between load balancing and minimizing memory access times.  
18.  P299 EDF是不是假定了deadline等于period? EDF和RMS没看明白，也就是对于RTOS来说，必须在限制的time frame里产生正确结果/task在规定的deadline之前被service (hard-real time，soft-real time无法保证，只能保证critical tasks have more preference than uncritical tasks)，对于软实时，前面介绍过的调度算法够用了，但是对于硬实时还不够，于是就有了RMS/EDF/PSS，"Note that providing a preemptive, priority-based scheduler only guarantees soft real-timefunctionality. Hard real-time systems must further guarantee that real-time tasks will be serviced in accord with their deadline requirements, and making such guarantees requires additional scheduling features."  
19.  P301 关于POSIX.1b，提供的两个类SCHED_FIFO和SCHED_RR，虽然采用的是FCFS和RR policy，但是好像是priority-based，所以可能就是multilevel，每一层同优先级队列里采用的是FCFS/RR。注意，如果是普通的FCFS和RR肯定是和priority无关的。  
20.  5.7节三个例子，Linux/Windows/Solaris Scheduling，Linux和Windows还要再看一下  
