# Chapter 4

1. P227 "In a Pthreads program, separate threads begin execution in a specified function...pass the name of the function where the new thread will begin execution" 你细品  
2. P227 Multithreaded C program using the Pthreads API 运行出错  
   > <https://stackoverflow.com/questions/1662909/undefined-reference-to-pthread-create-in-linux">
3. P228 如下，"The code is a snippet of code to wait for the completion of 10 threads created using the POSIX threads library. The `pthread_join` function is used to wait for a specified thread to complete execution. The second argument of pthread_join is a `void **`, which can be used to obtain the return value of the thread function. In this case, the second argument is `NULL`, indicating that the return value of the thread is not required...The `pthread_join` function blocks the ***calling thread***(the initial/parent thread in main()) until the specified thread terminates. So, in the provided code snippet, when i = 0, the main thread waits for the workers[0] thread to terminate. For other threads like workers[1], workers[5], they can terminate and exit before the main thread calls `pthread_join` on them. However, since pthread_join on those threads has not been called yet, they will remain as joinable threads and their resources will not be freed until they are joined by a `pthread_join` call...The threads that have completed their execution and called `pthread_exit()` will be waiting for their corresponding `pthread_join()` call to release their resources and complete their lifetime. The `pthread_join()` call unblocks the calling thread and returns the exit status of the thread being joined.Finally, the function returns the exit status of the thread being joined, which is the value that was passed to the pthread_exit() function when the joined thread terminated."  

    ``` C
    #define NUM_THREADS 10

    /* an array of threads to be joined upon */
    pthread_t workers[NUM_THREADS];

    for (int i = 0; i < NUM THREADS; i++) {
        pthread_join(workers[i], NULL);
    }
    ```

4. multithreading models没明白具体机制  
5. P237 关于fork-join "In some ways, this fork-join model is a synchronous version of thread pools in which a library determines the actual number of threads to create" 不太理解  
    > - This passage is discussing the "fork-join model" of thread creation, which is a method of creating and managing threads in a program. The model involves the main parent thread creating child threads, and then waiting for the child threads to finish and "join" with the parent thread. This process is considered to be a synchronous model of thread creation, where the creation of threads and the completion of tasks are in sync.
    > - The fork-join model can also be used as an implicit method of threading, where the threads are not created directly, but instead, parallel tasks are designated. In this case, a library is responsible for managing the number of threads that are created and for assigning tasks to threads.
    > - The fork-join model is characterized as being a synchronous version of thread pools, where the library determines the number of threads that should be created. The passage concludes by saying that the fork-join model is a synchronous version of thread pools, in which a library determines the actual number of threads to create.
6. 关于CPU/processor/core  
7. 关于multiprocessing/multiprogramming/multitasking：multiprogrammed和multitasking类似，只不过后者更突出一个"task"，凡是task总得有个响应时间，因此对于multitasking，一旦运行某个task达到一定时间(timeslice)，就自动退出，保证响应时间；对于multiprogrammed就是可以运行多个program/task，然而对于何时退出的要求肯定会宽松些，"A process is executed until it must wait, typically for the completion of some I/O request" BTW: multiprogrammed和multiprogramming好像还有点区别??  
8. 关于signal/exception/trap/interrupt:  
   > <https://stackoverflow.com/questions/45485093/signal-vs-exceptions-vs-hardware-interrupts-vs-traps>  
   > <https://stackoverflow.com/questions/13341870/signals-and-interrupts-a-comparison/13380714#13380714>
9. 关于Cancellation points:  
   > <https://blog.csdn.net/worldxie0565/article/details/12004951>  
   > If a pending cancellation request is detected when pthread_testcancel() is called, the thread will terminate immediately and any registered cleanup handlers will be called in LIFO order before the thread truly terminates. This means that the cleanup handlers will be executed in reverse order of registration, allowing for any necessary cleanup to be performed before the thread actually terminates.
10. static一个文件内可见，global全局可见；static所有threads共享，TLS thread-only；有时候会在声明TLS data时加上static关键字，代表只有thread退出时，TLS才会释放掉，不管thread里经过了几个function，这点就是static的特性，不管经过几个function，值都会保留上一次的值  
11. how does the kernel know that a application thread is about to block and issue a upcall to the thread library, telling it the applicaiton thread is about to block?  
   > - The kernel determines that an application thread is about to block and issues an upcall to the thread library by using a mechanism known as "blocking system calls". When an application thread makes a blocking system call, such as a read or write to a file, it enters a waiting state until the requested operation can be completed. The kernel, through its system call interface, detects that the thread is waiting and issues an upcall to the thread library, informing it that the application thread is about to block.
   > - In response to the upcall, the thread library can then perform any necessary bookkeeping, such as updating its data structures to reflect the change in state of the thread. The library can also choose to schedule another thread to run in place of the blocked thread, ensuring that the application continues to make progress even while one or more threads are blocked waiting for I/O or other operations to complete.
12. P250 关于LWP，为什么需要ta，"why we need lwp between user and kernel threads" // Scheduler activations为什么能Allows application to maintain the correct number of kernel threads  
13. P251 "The register set, stacks, and private storage area are known as the context of the thread"  
14. P253 "The varying level of sharing is possible because of the way a task is represented in the Linux kernel. A unique kernel data structure (specifically, struct task_struct) exists for each task in the system. This data structure, instead of storing data for the task, contains pointers to other data structures where these data are stored―for example, data structures that represent the list of open files, signal-handling information, and virtual memory. When fork() is invoked, a new task is created, along with a copy of all the associated data structures of the parent process. A new task is also created when the clone() system call is made. However, rather than copying all data structures, the new task points to the data structures of the parent task, depending on the set of flags passed to clone()." 深拷贝/浅拷贝在fork()/clone()里的应用，挺妙的，"From the kernel's perspective, both threads and processes are represented as tasks"，通过clone() system call with some flags passed as parameters可以达到create threads或者processes的效果  
15. P253 "Just as certain flags passed to clone() can distinguish between creating a task that behaves more like a process or a thread based upon the amount of sharing between the parent and child tasks, there are other flags that can be passed to clone() that allow a Linux container to be created" 6，clone()还能造容器  
16. the kernel does not know about user-level threads, as they are managed entirely within a user-space thread library (and the kernel schedules kernel threads: during system boot time on Linux systems, several kernel threads are created. Each thread performs a specific task, such as managing devices, memory management, or interrupt handling. The command `ps -ef` can be used to display the kernel threads on a running Linux system.), and do not involve the kernel; The kernel communicate with the thread library through scheduler activations: between the user-level and kernel threads is LWPs(light-weight processes), which plays an virtual processor's role for user-level threads, informing an application about certain events using upcalls. Kernel threads need not be associated with a process, whereas every user thread belongs to a process. Kernel threads are generally more expensive to maintain than user threads, as they must be represented with a kernel data structure.  
17. 一个程序想要跑/被CPU执行，就必须要靠操作系统调度，被OS加载进内存，然后一条条读进来开始运行；然而就像上面所说的那样，kernel只负责管理kernel threads，屏蔽掉了上层的user-level threads，所以user-level threads要想运行，就必须通过LWP映射到kernel当中，或者说"in order to run, a user-level thread must be attached to a Light Weight Process (LWP)." 用户空间里的thread library管理user-level threads，负责调度它们到available LWPs，LWPs和下层的kernel-level threads由kernel管理 (感觉LWPs也是一种kernel-level threads)。回头可以看看LWP的本质是什么  
   > P250 "To the user-thread library, the LWP appears to be a virtual processor on which the application can schedule a user thread to run. Each LWP is attached to a kernel thread, and it is kernel threads that the operating system schedules to run on physical processors. If a kernel thread blocks (such as while waiting for an I/O operation to complete), the LWP blocks as well. Up the chain, the user-level thread attached to the LWP also blocks"  
18. Can a multithreaded solution using multiple user-level threads achieve better performance on a multiprocessor system than on a single-processor system? Explain!!!! 亟待解决(感觉就是在问，一个process的所有threads能不能在多个processor/CPU/core上跑，或者说multithreads和multicore的关系)  
19. P226 注意synchronous threading和asynchronous threading的概念  
20. 关于多线程编程的结果输出顺序的问题：比如就用pthread_create()创建新线程，首先这个函数在创建好线程后不会block在那儿，程序会继续执行，也许是创建新的线程，那么由于是concurrent，再加上所有线程几乎可以看成是同时创建的，以及每个线程本身执行函数结束的快慢问题，综合以上因素，会导致每一次最后结果并行输出顺序的不一致，应该是正常现象  
   > the pthread_create() function does not wait for the thread it creates to complete. Instead, it returns immediately after creating the thread, allowing the parent thread to continue executing while the new thread runs concurrently. 
21. 感觉线程的出现是在一部分应用场景下，进程太笨重了，或者说是没必要，典型的例子可以看一下P218 web-server，从最开始的，server端全在一个main process里，有大量请求过来是没办法的，只能一次解决一个；然后转向一个process监听，来了一个请求，再开一个process处理，"In fact, this process-creation method was in common use before threads became popular."；最后发现，其实每一个process需要处理的任务是相同类似的，完全可以改成轻量级的thread，一个thread监听，请求来了再开一个thread，共享process的资源/基础组件，因为要做的task都是类似的  