# Chapter 2

1. system calls(6类)为操作系统提供的服务(8类 Figure 2.1)提供一个接口 system calls provide an interface to the services made available by an operating system, are available as functions typically written in C, C++, assembly，API(内含a set of functions)是对system calls的一层封装  
2. P102 The various resources controlled by the operating system can be thought of as devices  
3. 2.4 system services这一节怎么跟最开始配图里的services不一样？好迷惑。。。  
4. 2.5 linkers and loaders 有点迷  
5. system libraries是像C standard library(不同系统有不同实现，glibc 4 Linux/Unix-like，libc 4 macOS/iOS)/Windows API这种。not all system libraries is a part of OS，Windows API/glibc/libc这些是OS的一部分，甚至像glibc/libc是直接integrated into kernel的，至于其余的诸如Windows API，并没有directly into kernel，但还是built into OS；同时有些本身虽然是system library，然而并不是OS的一部分，并不会distributed and installed with the OS，但是可以included as a separate package that can be downloaded and installed. 存疑  
   > - A system library is a collection of pre-written software functions that provide additional functionality to a program. These libraries are typically provided by the operating system, designed to be platform-independent, allowing developers to write code that can be easily ported to different platforms and to be used by application developers to perform common tasks.
   > - All system libraries that are integrated into the kernel are considered to be a part of the operating system(glibc/libc), as they are tightly integrated with the kernel and provide essential functionality for the operating system and the applications that run on it. However, not all system libraries that are considered to be a part of the operating system are integrated into the kernel(Windows API). Some system libraries may be distributed and installed as part of the operating system, but not integrated into the kernel.
6. 关于OS message copying && context switching to communicate:  
> When two user-level services must communicate, messages must be copied between the services because the services reside in separate address spaces. This means that the memory used by each service is isolated from the memory used by the other service, and direct access to that memory is not allowed. To allow the services to communicate, the operating system must provide a mechanism for passing messages between the services. The most common approach is to copy the message from the sender's address space into a shared memory area or a buffer, which is then read by the receiver. This copying process is necessary because it ensures that the sender and receiver have separate and distinct copies of the message, and that any changes made to the message by one service do not affect the other service. This is a security mechanism that ensures that no user-level service can modify the memory of another service without explicit permission of the operating system, thus it is a way to prevent malicious services to corrupt or steal data from other services.
> Yes, the operating system (OS) may need to switch from one process to another in order to exchange messages between user-level services. This is because when two services are communicating, the OS must ensure that both services are able to access the shared memory or buffer where the message is stored. To accomplish this, the OS may use a technique called context switching, which involves saving the current state of a process and restoring the state of another process. This allows the OS to switch between the two services, allowing each service to access the shared memory and read or write the message. This process can be time consuming and can add an additional overhead to the communication. The context switch can be triggered by the sender service when it wants to send a message, in this case the OS would save the context of the sender and switch to the receiver service to allow it to read the message, then switch back to the sender service. The receiver service can also trigger a context switch to receive a message by requesting the OS to send a message. Note that context switching can add an overhead to the communication process, and it can be reduced or avoided by using inter-process communication mechanisms that allows the services to communicate directly without the need of copying messages and switching between processes.  
7. "Generally, these systems have fewer layers with more functionality, providing most of the advantages of modularized code while avoiding the problems of layer definition and interaction."，相比于monolithic approach(紧耦合，改动一个，波及一片)，layered approach(松耦合，modular approach的一种，上面一层的实现完全依赖于下面一层)虽然更容易debug，但是太多layers也不好，因为上层想要得到底层服务的成本就高了，层数越多效率可能会更低更慢，同时"appropriately defining the functionality of each layer"，清晰地定义清楚每一层也很难，因此会采取fewer layers  
8. LKMs通过shared memory to communicate rather message copying and context switching.
   > **NOTICED**: It is important to note that this direct communication between modules is only possible if the modules are part of the kernel and share the same memory space, this approach is not possible for user-level services as they reside in different address spaces and do not share the same memory space.  
9.  关于LKMs，microkernel与layered approach的"结合"，但是相比二者更加dynamically && flexible。microkernel只保留core services在kernel mode里，而LKM可以随时inserted into the kernel；LKM each kernel section都有定义的接口，就像layered approach的每一层一样，但是LKM里any module can call any other module，而不是被限制只能call pre-layer:  
    > Loadable kernel modules (LKMs) allow for a dynamic and modular kernel in **Linux**(hybrid systems, monolithic but modular through using LKMs)while maintaining the performance benefits of a monolithic system in several ways:
    > - Dynamic loading and unloading: LKMs allows for the loading and unloading of kernel code at runtime. This allows for the addition and removal of functionality without the need for a full system reboot. This can be useful for adding or removing support for new hardware, or for disabling a malfunctioning module.
    > - Reduced memory footprint: LKMs only load the code that is needed for the current system configuration, reducing the overall memory footprint of the kernel. This can be beneficial for systems with limited memory resources.
    > - Increased flexibility: LKMs allows for the separation of the kernel code into smaller, more manageable pieces, which can be developed and tested independently. This can make it easier to add new features and fix bugs, as well as to customize the kernel for specific use cases.
    > - Performance benefits: LKMs can improve performance by allowing the kernel to only load the code that is needed for the current configuration. This can reduce the amount of code that needs to be executed, leading to improved performance.
    > - Security benefits: LKMs can be used to add security features to the kernel, such as anti-malware and intrusion detection. This can be beneficial for systems that require a higher level of security.
10. 关于POSIX(APIs):  
   >  the POSIX standard is a base standard and many other standards have been derived from it. POSIX.1 defines the core functionality of the API, including file I/O, process and thread management, and interprocess communication. POSIX.2 adds additional functionality such as regular expressions, dynamic loading of libraries, and a standard shell. POSIX.4 extends real-time functionality to the API. Some operating systems, such as Linux and macOS, have a high degree of POSIX compliance, which means that they provide a large subset of the POSIX API. Other operating systems, such as Windows, have a low degree of POSIX compliance, and provide only a subset of the POSIX API. Additionally, some operating systems have implemented POSIX compatibility layers or libraries, such as Cygwin on Windows, which allows POSIX-compliant software to be run on non-compliant systems.